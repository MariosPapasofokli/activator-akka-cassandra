<html>
<head>
    <title>Akka and Cassandra</title>
</head>
<body>
<div>
    <h2>Akka and Cassandra</h2>

    <p>
        In this tutorial, I am going to use the Spray-Client, DataStacks Cassandra driver and Akka to build an
        application that downloads tweets and then stores their id, text, name and date in a Cassandra table.
        It shows you how to build a simple Akka application with just a few actors, how to use Akka IO to make HTTP
        requests, and how to store the data in Cassandra. It also demonstrates approaches to testing of such applications,
        including performance tests.
    </p>
    <p>
        <img src="tutorial/overall.png" title="Overall structure"/>
    </p>
    <p>
        Learn how to construct <a href="http://akka.io" target="_blank">Akka</a>-based command-line applications;
        how to test them (using <a href="http://doc.akka.io/docs/akka/snapshot/scala/testing.html" target="_blank">TestKit</a>
        and <a href="http://etorreborre.github.io/specs2/" target="_blank">Specs2</a>; and how to use Spray-Client
        <a href="http://spray.io/" target="_blank">Spray</a> to make asynchronous HTTP requests using.
    </p>
</div>
<div>
    <h2>The core</h2>
    <p>
        I begin by constructing the core of our system. It contains three actors: two that interact with the tweet database
        and one that downloads the tweets. The <code>TwitterReadActor</code> reads from the <code>Cluster</code>, the
        <code>TweetWriteActor</code> writes into the <code>Cluster</code>, and the <code>TweetScanActor</code> downloads
        the tweets and passes them to the <code>TweetWriteActor</code> to be written.
        These dependencies are expressed in the actors' constructors:
    </p>
<pre><code>
class TweetReadActor(cluster: Cluster) extends Actor {
  ...
}

class TweetWriterActor(cluster: Cluster) extends Actor {
  ...
}

class TweetScanActor(tweetWrite: ActorRef, queryUrl: String => String) extends Actor {
  ...
}
</code></pre>
    <p>
        The constructor parameter of the <em>read</em> and <em>write</em> actors is just the Cassandra <code>Cluster</code>
        instance; the <em>scan</em> actor takes an <code>ActorRef</code> of the <em>write</em> actor and a function that
        given a <code>String</code> query can construct the query URL to download the tweets. (This is how I construct
        keyword searches, for example.)
    </p>
    <p>
        To construct our application, all we need to do is to instantiate the actors in the right sequence:
    </p>
<pre><code>
val system = ActorSystem()

def queryUrl(query: String): String = ???
val cluster: Cluster = ???

val reader  = system.actorOf(Props(new TweetReaderActor(cluster)))
val writer  = system.actorOf(Props(new TweetWriterActor(cluster)))
val scanner = system.actorOf(Props(new TweetScannerActor(writer, queryUrl)))
</code></pre>
    <p>
        I shall leave the implementation of <code>cluster</code> and <code>queryUrl</code> as <code>???</code>: the
        <em>kink in the chain</em>, <em>logical inconsistency in otherwise perfect system</em>, a.k.a.
        <a href="http://www.haskell.org/haskellwiki/Bottom" target="_blank">the bottom type</a>.
    </p>
</div>
<div>
    <h2>Writing to Cassandra</h2>
    <p>
        Now that we have the structure in place, we can take a look at the <code>TwitterWriterActor</code>. It receives
        instances of <code>Tweet</code>, which it writes to the <code>tweets</code> keyspace in Cassandra.
    </p>
<pre><code>
class TweetWriterActor(cluster: Cluster) extends Actor {
  val session = cluster.connect(Keyspaces.akkaCassandra)
  val preparedStatement = session.prepare("INSERT INTO tweets(key, user_user, text, createdat) VALUES (?, ?, ?, ?);")

  def receive: Receive = {
    case tweets: List[Tweet] =>
    case tweet: Tweet        =>
  }
}
</code></pre>
    <p>
      To save the tweets, we need to <em>connect</em> to the correct keyspace, which gives us the Cassandra <code>Session</code>.
      Because we try to be as efficient as possible, we will take advantage of Cassandra's <code>PreparedStatement</code>s
      and <code>BoundStatement</code>s. The <code>PreparedStatement</code> is a pre-chewed CQL statement, a <code>BoundStatement</code>
      is a <code>PreparedStatemnt</code> whose parameter values are set.
    </p>
    <p>
        So, this gives us the hint of the what the <code>saveTweet</code> function needs to do.
    </p>
<pre><code>
class TweetWriterActor(cluster: Cluster) extends Actor {
  val session = cluster.connect(Keyspaces.akkaCassandra)
  val preparedStatement = session.prepare("INSERT INTO tweets(key, user_user, text, createdat) VALUES (?, ?, ?, ?);")

  def saveTweet(tweet: Tweet): Unit =
    session.executeAsync(preparedStatement.bind(tweet.id.id, tweet.user.user, tweet.text.text, tweet.createdAt))

  def receive: Receive = {
    case tweets: List[Tweet] =>
    case tweet: Tweet        =>
  }
}
</code></pre>
    <p>
        The only thing that remains to be done is to use it in the <code>receive</code> partial function.
    </p>
<code><pre>
class TweetWriterActor(cluster: Cluster) extends Actor {
  val session = cluster.connect(Keyspaces.akkaCassandra)
  val preparedStatement = session.prepare("INSERT INTO tweets(key, user_user, text, createdat) VALUES (?, ?, ?, ?);")

  def saveTweet(tweet: Tweet): Unit =
    session.executeAsync(preparedStatement.bind(tweet.id.id, tweet.user.user, tweet.text.text, tweet.createdAt))

  def receive: Receive = {
    case tweets: List[Tweet] => tweets foreach saveTweet
    case tweet: Tweet        => saveTweet(tweet)
  }
}
</pre></code>
    <p>So, we have code that saves instances of <code>Tweet</code> to the keyspace in our Cassandra cluster.</p>
</div>
<div>
    <h2>Reading from Cassandra</h2>
    <p>
        Reading the data is ever so slightly more complex: we would like to support the <em>count</em> and <em>find all</em>
        operations. Then, we need to be able to construct Cassandra queries; then, given a Cassandra <code>Row</code>,
        we need to be able to turn it into our <code>Tweet</code> object. Naturally, we also want to take advantage of the
        asynchronous nature of the Cassandra driver. Luckily, things won't be that complex. Let me begin with the structure
        of the <code>TweetReaderActor</code>.
    </p>
<code><pre>
object TweetReaderActor {
  case class FindAll(maximum: Int = 100)
  case object CountAll
}

class TweetReaderActor(cluster: Cluster) extends Actor {
  val session = cluster.connect(Keyspaces.akkaCassandra)
  val countAll  = new BoundStatement(session.prepare("select count(*) from tweets;"))

  def receive: Receive = {
    case FindAll(maximum)  =>
      // reply with List[Tweet]
    case CountAll =>
      // reply with Long
  }
}
</pre></code>
    <p>
        In the companion object, I have defined the <code>FindAll</code> and <code>CountAll</code> messages that our
        actor will react to; I have also left in the code that gives us the <code>Session</code> and then used the
        <code>Session</code> to construct a <code>BoundStatement</code> that counts all rows. Next up, we need to be
        able to construct an instance of <code>Tweet</code> given a <code>Row</code>.
    </p>
<code><pre>
class TweetReaderActor(cluster: Cluster) extends Actor {
  ...

  def buildTweet(r: Row): Tweet = {
    val id = r.getString("key")
    val user = r.getString("user_user")
    val text = r.getString("text")
    val createdAt = r.getDate("createdat")
    Tweet(id, user, text, createdAt)
  }
  ...
}
</pre></code>
    <p>
        Again, nothing too dramatic: we simply pick the values of the columns in the row and use them to make an instance
        of <code>Tweet</code>. Now, let's wire in the Cassandra magic. We would like to <em>execute</em> (asynchronously)
        some <em>query</em>; map the <em>rows</em> returned from that query execution to turn them into the <em>tweets</em>;
        and then <em>pipe</em> the result to the <em>sender</em>. (The italic text gives plenty of hints, so let's just
        get the code in.)
    </p>
<code><pre>
class TweetReaderActor(cluster: Cluster) extends Actor {
  val session = cluster.connect(Keyspaces.akkaCassandra)
  val countAll  = new BoundStatement(session.prepare("select count(*) from tweets;"))

  import scala.collection.JavaConversions._
  import cassandra.resultset._
  import context.dispatcher
  import akka.pattern.pipe

  def buildTweet(r: Row): Tweet = {...}

  def receive: Receive = {
    case FindAll(maximum)  =>
      val query = QueryBuilder.select().all().from(Keyspaces.akkaCassandra, "tweets").limit(maximum)
      session.executeAsync(query) map(_.all().map(buildTweet).toList) pipeTo sender
    case CountAll =>
      session.executeAsync(countAll) map(_.one.getLong(0)) pipeTo sender
  }
}
</pre></code>
    <p>
        Let me dissect the <code>FindAll</code> message handler. First, I construct the <code>query</code> using
        Cassandra's <code>QueryBuilder</code> (which I have renamed to <code>QB</code> in the imports). This is
        ordinary Cassandra code.<br/>
        What follows is much more interesting: I call the <code>executeAsync</code> method on the <code>session</code>,
        which returns <code>ResultSetFuture</code>. Using implicit conversion in <code>cassandra.resultset._</code>, I turn
        the <code>ResultSetFuture</code> into Scala's <code>Future[ResultSet]</code>. This allows me to use the <code>Future.map</code>
        method to turn the <code>ResultSet</code> into <code>List[Tweet]</code>.<br/>
        Calling <code>session.executeAsync(query) map</code> expects, as its parameter, a function from <code>ResultSet</code>
        to some type <code>B</code>. In our case, <code>B</code> is <code>List[Tweet]</code>. The <code>ResultSet</code> contains
        the method <code>all()</code>, which returns <code>java.util.List[Row]</code>. To be able to <code>map</code> over
        the <code>java.util.List[Row]</code>, we need to turn it into the Scala <code>List[Row]</code>. To do so, we bring in
        the implicit conversions in <code>scala.collection.JavaConversions</code>. And now, we can complete the parameter of the
        <code>Future.map</code> function.<br/>
        <code>session.executeAsync(query) map(_.all().map(buildTweet).toList)</code> therefore gives us <code>Future[List[Tweet]]</code>,
        which is tantalizingly close to what we need. We do not want to block for the result, and we are too lazy to use the
        <code>onSuccess</code> function, because all that it would do is to pass on the result to the <code>sender</code>. So,
        instead, we <em>pipe</em> the success of the future to the sender! That completes the picture, explaining the entire
        line <code>session.executeAsync(query) map(_.all().map(buildTweet).toList) pipeTo sender</code>.
    </p>
</div>
<div>
    <h2>Connecting to Cassandra</h2>
    <p>Before I move on, I need to explain where the <code>Cluster</code> value comes from. Thinking about the system
        we are writing, we may need to have different values of <code>Cluster</code> for tests and for the main system.
        Moreover, the test <code>Cluster</code> will most likely need some special setup. Because I can't decide just
        yet, I'd simply define that there is a <code>CassandraCluster</code> trait that returns the <code>Cluster</code>;
        and to give implementations that do the right thing: one that loads the configuration from the <code>ActorSystem</code>'s
        configuration, and one that is hard-coded to be used in tests.
    </p>
<code><pre>
trait CassandraCluster {
  def cluster: Cluster
}
</pre></code>
    <p>The configuration-based implementation and the test configuration differ only in the values they use to make the
    <code>Cluster</code> instance.</p>
<code><pre>
// in src/scala/main
trait ConfigCassandraCluster extends CassandraCluster {
  def system: ActorSystem

  private def config = system.settings.config

  import scala.collection.JavaConversions._
  private val cassandraConfig = config.getConfig("akka-cassandra.main.db.cassandra")
  private val port = cassandraConfig.getInt("port")
  private val hosts = cassandraConfig.getStringList("hosts").toList

  lazy val cluster: Cluster =
    Cluster.builder().
      addContactPoints(hosts: _*).
      withCompression(ProtocolOptions.Compression.SNAPPY).
      withPort(port).
      build()
}

// in src/scala/test
trait TestCassandraCluster extends CassandraCluster {
  def system: ActorSystem

  private def config = system.settings.config

  import scala.collection.JavaConversions._
  private val cassandraConfig = config.getConfig("akka-cassandra.test.db.cassandra")
  private val port = cassandraConfig.getInt("port")
  private val hosts = cassandraConfig.getStringList("hosts").toList

  lazy val cluster: Cluster =
    Cluster.builder().
      addContactPoints(hosts: _*).
      withPort(port).
      withCompression(ProtocolOptions.Compression.SNAPPY).
      build()

}
</pre></code>
    <p>
        This allows me to mix in the appropriate trait and get the properly configured <code>Cluster</code>. But there's
        a little twist when it comes to tests: for the tests, I want to have the cluster in a well-known state. To solve
        this, I create the <code>CleanCassandra</code> trait that resets the <code>Cluster</code> given by some
        <code>CassandraCluster.cluster</code>.
    </p>
<code><pre>
trait CleanCassandra extends SpecificationStructure {
  this: CassandraCluster =>

  private def runClq(session: Session, file: File): Unit = {
    val query = Source.fromFile(file).mkString
    query.split(";").foreach(session.execute)
  }

  private def runAllClqs(): Unit = {
    val session = cluster.connect(Keyspaces.akkaCassandra)
    val uri = getClass.getResource("/").toURI
    new File(uri).listFiles().foreach { file =>
      if (file.getName.endsWith(".cql")) runClq(session, file)
    }
    session.shutdown()
  }

  override def map(fs: => Fragments) = super.map(fs) insert Step(runAllClqs())
}
</pre></code>
    <p>When I mix in this trait into my test, it registers the <code>runAllClqs()</code> steps to be executed <em>before</em>
    all other steps in the test.</p>
</div>
<div>
    <h2>Testing</h2>
    <p>
        And so, I can write my first test that verifies that the <code>TwitterReaderActor</code> and <code>TwitterWriterActor</code>
        indeed work as expected. The body of the test is rather long, but it is not too difficult to conceptually follow
        what is happening.
    </p>
<code><pre>
class TweetActorsSpec extends TestKit(ActorSystem())
  with SpecificationLike with TestCassandraCluster with CleanCassandra with ImplicitSender {
  sequential

  val writer = TestActorRef(new TweetWriterActor(cluster))
  val reader = TestActorRef(new TweetReaderActor(cluster))

  "Slow & steady" >> {
    def write(count: Int): List[Tweet] = {
      val tweets = (1 to count).map(id => Tweet(id.toString, "@honzam399", "Yay!", new Date))
      tweets.foreach(writer !)
      Thread.sleep(1000)    // wait for the tweets to hit the db
      tweets.toList
    }

    "Single tweet" in {
      val tweet = write(1).head

      reader ! FindAll(1)
      val res = expectMsgType[List[Tweet]]
      res mustEqual List(tweet)
    }

    "100 tweets" in {
      val writtenTweets = write(100)

      reader ! FindAll(100)
      val readTweets = expectMsgType[List[Tweet]]
      readTweets must containTheSameElementsAs(writtenTweets)
    }
  }

}
</pre></code>
    <p>After </p>
</div>
</body>
</html>
